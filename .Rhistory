## Defining the inverse function
## Defining descriptive text
text <- "Modified Gompertz equation (4 parameters)"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))
class(returnList) <- "drcMean"
invisible(returnList)
}
"E.3" <-
function(fixed = c(NA, NA, NA), names = c("b", "d", "e"))
{
## Checking arguments
numParm <- 3
if (!is.character(names) | !(length(names) == numParm)) {stop("Not correct 'names' argument")}
if (!(length(fixed) == numParm)) {stop("Not correct 'fixed' argument")}
## Fixing parameters (using argument 'fixed')
notFixed <- is.na(fixed)
parmVec <- rep(0, numParm)
parmVec[!notFixed] <- fixed[!notFixed]
## Defining the non-linear function
fct <- function(x, parm)
{
parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)
parmMat[, notFixed] <- parm
E3.fun(x, parm[,1], parm[,2], parm[,3])
}
## Defining self starter function
ssfct <- function(dataf)
{
x <- dataf[, 1]
y <- dataf[, 2]
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log(-log((d - y)/d))
coefs <- coef( lm(pseudoY ~ x))
k <- coefs[1]; b <- coefs[2]
e <- -k/b
value <- c(b,d,e)
return(value[notFixed])
}
## Defining names
pnames <- names[notFixed]
## Defining derivatives
## Defining the ED function
## Defining the inverse function
## Defining descriptive text
text <- "Modified Gompertz equation (3 parameters)"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))
class(returnList) <- "drcMean"
invisible(returnList)
}
"E.2" <- function(fixed = c(NA, NA), names = c("b", "e"))
{
## Checking arguments
numParm <- 2
if (!is.character(names) | !(length(names) == numParm)) {stop("Not correct 'names' argument")}
if (!(length(fixed) == numParm)) {stop("Not correct 'fixed' argument")}
## Fixing parameters (using argument 'fixed')
notFixed <- is.na(fixed)
parmVec <- rep(0, numParm)
parmVec[!notFixed] <- fixed[!notFixed]
## Defining the non-linear function
fct <- function(x, parm)
{
parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)
parmMat[, notFixed] <- parm
E2.fun(x, parm[,1], parm[,2])
}
## Defining self starter function
ssfct <- function(dataf)
{
x <- dataf[, 1]
y <- dataf[, 2]
## Linear regression on pseudo y values
pseudoY <- log(-log(1.01 - y))
coefs <- coef( lm(pseudoY ~ x))
k <- coefs[1]; b <- coefs[2]
e <- -k/b
value <- c(b, e)
return(value[notFixed])
}
## Defining names
pnames <- names[notFixed]
## Defining derivatives
## Defining the ED function
## Defining the inverse function
## Defining descriptive text
text <- "Modified Gompertz equation (2 parameters)"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))
class(returnList) <- "drcMean"
invisible(returnList)
}
# drm fit
model <- drm(weightFree ~ DAE, fct = E.3(), data = beetGrowth)
model.2 <- drm(weightFree ~ DAE, fct = E.4(), data = beetGrowth)
model.3 <- drm(weightFree/max(weightFree) ~ DAE, fct = E.2(), data = beetGrowth)
# nls fit
model <- nls(weightInf ~ NLS.E3(DAE, b, d, e), data = beetGrowth)
# model.2 <- drm(weightFree ~ DAE, fct = E.4(), data = beetGrowth)
# model.3 <- drm(weightFree/max(weightFree) ~ DAE, fct = E.2(), data = beetGrowth)
summary(model)
# drm fit
model <- drm(weightFree ~ DAE, fct = E.3(), data = beetGrowth)
# model.2 <- drm(weightFree ~ DAE, fct = E.4(), data = beetGrowth)
# model.3 <- drm(weightFree/max(weightFree) ~ DAE, fct = E.2(), data = beetGrowth)
summary(model)
# nls fit
model <- nls(weightInf ~ NLS.E3(DAE, b, d, e), data = beetGrowth)
# model.2 <- drm(weightFree ~ DAE, fct = E.4(), data = beetGrowth)
# model.3 <- drm(weightFree/max(weightFree) ~ DAE, fct = E.2(), data = beetGrowth)
summary(model)
# drm fit
model <- drm(weightInf ~ DAE, fct = E.3(), data = beetGrowth)
# model.2 <- drm(weightFree ~ DAE, fct = E.4(), data = beetGrowth)
# model.3 <- drm(weightFree/max(weightFree) ~ DAE, fct = E.2(), data = beetGrowth)
summary(model)
plot(model, log="")
d <- 10; c <- 2; e <- 7; b <- 0.5
curve( G4.fun(x, b, c, d, e), xlim = c(0, 20) , xlab="X", ylab = "Y")
curve( L4.fun(x, b, c, d, e), add = T, col = "red" )
curve( E4.fun(x, b, c, d, e), add = T, col = "blue" )
model <- nls(FW ~ NLS.LL4(Dose, b, c, d, e), data = brassica)
data(brassica)
model <- nls(FW ~ NLS.LL4(Dose, b, c, d, e), data = brassica)
model <- nls(FW ~ NLS.LL3(Dose, b, d, e), data = brassica)
model <- nls(FW/max(FW) ~ NLS.LL2(Dose, b, e), data = brassica)
model <- drm(FW ~ Dose, fct = LL.4(), data = brassica)
summary(model)
plot(model)
model <- nls(FW ~ NLS.LL4(Dose, b, c, d, e), data = brassica)
summary(model)
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
model <- nls(FW ~ NLS.W2.3(Dose, b, d, e), data = brassica)
model <- nls(FW/max(FW) ~ NLS.W2.2(Dose, b, e), data = brassica)
model <- drm(FW ~ Dose, fct = LL.4(), data = brassica)
model <- drm(FW ~ Dose, fct = W2.4(), data = brassica)
summary(model)
plot(model)
# Weibul type 2 Function for bioassay work
# Edited on 07/02/2020
W2.4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c + (d - c) * exp ( - exp ( - b*(log(x + 0.000001) - log(e))))
}
W2.4.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
c <- min(y) * 0.95
## Linear regression on pseudo y values
pseudoY <- log( - log( (y - c) / (d - c) ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- - coefs[2]
e <- exp(coefs[1]/coefs[2])
value <- c(b, c, d, e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.W2.4 <- selfStart(W2.4.fun, W2.4.init, parameters=c("b", "c", "d", "e"))
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
summary(model)
model <- drm(FW ~ Dose, fct = W2.4(), data = brassica)
summary(model)
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
summary(model)
model <- drm(FW ~ Dose, fct = W2.4(), data = brassica)
summary(model)
plot(model)
weibull
weibull2
?weibull1
model <- drm(FW ~ Dose, fct = W1.4(), data = brassica)
summary(model)
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
summary(model)
# Weibul type 1 Function for bioassay work
# Edited on 07/02/2020
W1.4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c + (d - c) * exp ( - exp ( - b*(log(x + 0.000001) - log(e))))
}
W1.4.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
c <- min(y) * 0.95
## Linear regression on pseudo y values
pseudoY <- log( - log( (y - c) / (d - c) ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- - coefs[2]
e <- exp(coefs[1]/coefs[2])
value <- c(b, c, d, e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.W1.4 <- selfStart(W1.4.fun, W1.4.init, parameters=c("b", "c", "d", "e"))
# Weibul type 2 Function for bioassay work nlsW1.3
# Edited on 07/02/2020
W1.3.fun <- function(predictor, b, d, e) {
x <- predictor
d * exp ( - exp ( - b*(log(x+0.000001)-log(e))))
}
W1.3.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log( - log( y / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- coefs[1]
e <- - coefs[2]
value <- c(b, d, e)
names(value) <- mCall[c("b", "d", "e")]
value
}
NLS.W1.3 <- selfStart(W1.3.fun, W1.3.init, parameters=c("b", "d", "e"))
# Weibul type 2 Function for bioassay work nlsW1.3
# Edited on 07/02/2020
W1.2.fun <- function(predictor, b, e) {
x <- predictor
exp ( - exp ( - b*(log(x+0.000001)-log(e))))
}
W1.2.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- 1
## Linear regression on pseudo y values
pseudoY <- log( - log( y / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- coefs[1]
e <- - coefs[2]
value <- c(b, e)
names(value) <- mCall[c("b", "e")]
value
}
NLS.W1.2 <- selfStart(W1.2.fun, W1.2.init, parameters=c("b", "e"))
data(brassica)
model <- nls(FW ~ NLS.W1.4(Dose, b, c, d, e), data = brassica)
model <- nls(FW ~ NLS.W1.3(Dose, b, d, e), data = brassica)
# Weibul type 1 Function for bioassay work
# Edited on 07/02/2020
W1.4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c + (d - c) * exp ( - exp ( - b*(log(x + 0.000001) - log(e))))
}
W1.4.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
c <- min(y) * 0.95
## Linear regression on pseudo y values
pseudoY <- log( - log( (y - c) / (d - c) ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- - coefs[2]
e <- exp(coefs[1]/coefs[2])
value <- c(b, c, d, e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.W1.4 <- selfStart(W1.4.fun, W1.4.init, parameters=c("b", "c", "d", "e"))
# Weibul type 2 Function for bioassay work nlsW1.3
# Edited on 07/02/2020
W1.3.fun <- function(predictor, b, d, e) {
x <- predictor
d * exp ( - exp ( - b*(log(x+0.000001)-log(e))))
}
W1.3.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log( - log( y / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- - coefs[2]
e <- exp(coefs[1]/coefs[2])
value <- c(b, d, e)
names(value) <- mCall[c("b", "d", "e")]
value
}
NLS.W1.3 <- selfStart(W1.3.fun, W1.3.init, parameters=c("b", "d", "e"))
# Weibul type 2 Function for bioassay work nlsW1.3
# Edited on 07/02/2020
W1.2.fun <- function(predictor, b, e) {
x <- predictor
exp ( - exp ( - b*(log(x+0.000001)-log(e))))
}
W1.2.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- 1
## Linear regression on pseudo y values
pseudoY <- log( - log( y / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )
b <- - coefs[2]
e <- exp(coefs[1]/coefs[2])
value <- c(b, e)
names(value) <- mCall[c("b", "e")]
value
}
NLS.W1.2 <- selfStart(W1.2.fun, W1.2.init, parameters=c("b", "e"))
model <- nls(FW ~ NLS.W1.4(Dose, b, c, d, e), data = brassica)
model <- nls(FW ~ NLS.W1.3(Dose, b, d, e), data = brassica)
model <- nls(FW/max(FW) ~ NLS.W1.2(Dose, b, e), data = brassica)
summary(model)
model <- nls(FW ~ NLS.W1.4(Dose, b, c, d, e), data = brassica)
summary(model)
model <- drm(FW ~ Dose, fct = W1.4(), data = brassica)
summary(model)
# Weibul type 1 Function for bioassay work nlsW2.4
# Edited on 07/02/2020
W2.4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c + (d - c) * (1 - exp( - exp (b * (log(x + 0.0000001) - log(e)))))
}
W2.4.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
c <- min(y) * 0.95
## Linear regression on pseudo y values
pseudoY <- log( - log( (d - y ) / (d - c) ) )
coefs <- coef( lm(pseudoY ~ log(x+0.0000001)) )
b <- coefs[1]
e <- exp( - coefs[2]/b)
value <- c(b, c, d, e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.W2.4 <- selfStart(W2.4.fun, W2.4.init, parameters=c("b", "c", "d", "e"))
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
summary(model)
model <- drm(FW ~ Dose, fct = W2.4(), data = brassica)
summary(model)
# Weibul type 1 Function for bioassay work nlsW2.4
# Edited on 07/02/2020
W2.4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c + (d - c) * (1 - exp( - exp (b * (log(x + 0.0000001) - log(e)))))
}
W2.4.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
c <- min(y) * 0.95
## Linear regression on pseudo y values
pseudoY <- log( - log( (d - y ) / (d - c) ) )
coefs <- coef( lm(pseudoY ~ log(x+0.0000001)) )
b <- coefs[1]
e <- exp( - coefs[2]/b)
value <- c(b, c, d, e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.W2.4 <- selfStart(W2.4.fun, W2.4.init, parameters=c("b", "c", "d", "e"))
# Weibul type 1 Function for bioassay work nlsW2.3
# Edited on 07/02/2020
W2.3.fun <- function(predictor, b, d, e) {
x <- predictor
d * (1 - exp( - exp (b * (log(x + 0.0000001) - log(e)))))
}
W2.3.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log( - log( (d - y ) / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.0000001)) )
b <- coefs[1]
e <- exp( - coefs[2]/b)
value <- c(b, d, e)
names(value) <- mCall[c("b", "d", "e")]
value
}
NLS.W2.3 <- selfStart(W2.3.fun, W2.3.init, parameters=c("b", "d", "e"))
# Weibul type 1 Function for bioassay work nlsW2.3
# Edited on 07/02/2020
W2.2.fun <- function(predictor, b, e) {
x <- predictor
1 - exp( - exp (b * (log(x + 0.0000001) - log(e))))
}
W2.2.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- 1
## Linear regression on pseudo y values
pseudoY <- log( - log( (d - y ) / d ) )
coefs <- coef( lm(pseudoY ~ log(x+0.0000001)) )
b <- coefs[1]
e <- exp( - coefs[2]/b)
value <- c(b, e)
names(value) <- mCall[c("b", "e")]
value
}
NLS.W2.2 <- selfStart(W2.2.fun, W2.2.init, parameters=c("b", "e"))
model <- nls(FW ~ NLS.W2.4(Dose, b, c, d, e), data = brassica)
model <- nls(FW ~ NLS.W1.3(Dose, b, d, e), data = brassica)
model <- nls(FW/max(FW) ~ NLS.W1.2(Dose, b, e), data = brassica)
model <- drm(FW ~ Dose, fct = W2.4(), data = brassica)
summary(model)
plot(model)
d <- 10; e <- 10; b <- 5
curve( LL.3.fun(x, b, d, e), xlim = c(0.1, 20) , xlab="X", ylab = "Y", col = "red")
curve( W1.3.fun(x, b, d, e), add = T, col = "black" )
#Log-Logistic Function for bioassay work nlsLL.4
LL4.fun <- function(predictor, b, c, d, e) {
x <- predictor
c+(d-c)/(1+exp(- b*(log(x+0.000001)-log(e))))
}
#NLSLL.4mean <- deriv(~c+(d-c)/(1+exp(b*(log(predictor+0.000001)-log(ED50)))),c("c","d","b","ED50"),function(predictor,c,d,b,ED50){})
LL4.Init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
c <- min(y) * 0.95
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log((d-y)/(y-c))
coefs <- coef( lm(pseudoY ~ log(x+0.000001)))
k <- coefs[1]; b <- - coefs[2]
e <- exp(k/b)
value <- c(b,c,d,e)
names(value) <- mCall[c("b", "c", "d", "e")]
value
}
NLS.LL4 <- selfStart(LL4.fun, LL4.Init, parameters=c("b", "c", "d", "e"))
# Log-Logistic Function for bioassay work nlsLL.3
# Edited on 07/02/2020
LL3.fun <- function(predictor, b, d, e) {
x <- predictor
d/(1+exp(-b*(log(x+0.000001)-log(e))))
}
LL3.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- max(y) * 1.05
## Linear regression on pseudo y values
pseudoY <- log((d-y)/(y+0.00001))
coefs <- coef( lm(pseudoY ~ log(x+0.000001)))
k <- coefs[1]; b <- - coefs[2]
e <- exp(k/b)
value <- c(b,d,e)
names(value) <- mCall[c("b", "d", "e")]
value
}
NLS.LL3 <- selfStart(LL3.fun, LL3.init, parameters=c("b", "d", "e"))
# Log-Logistic Function for bioassay work nlsLL.2
# Edited on 07/02/2020
LL2.fun <- function(predictor, b, e) {
x <- predictor
1/(1+exp(-b*(log(x+0.000001)-log(e))))
}
LL2.init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
x <-  xy[, "x"]; y <- xy[, "y"]
d <- 1
## Linear regression on pseudo y values
pseudoY <- log((d-y)/(y+0.00001))
coefs <- coef( lm(pseudoY ~ log(x+0.000001)))
k <- coefs[1]; b <- - coefs[2]
e <- exp(k/b)
value <- c(b,e)
names(value) <- mCall[c("b", "e")]
value
}
NLS.LL2 <- selfStart(LL2.fun, LL2.init, parameters=c("b", "e"))
d <- 10; e <- 10; b <- 5
curve( LL.3.fun(x, b, d, e), xlim = c(0.1, 20) , xlab="X", ylab = "Y", col = "red")
curve( LL3.fun(x, b, d, e), xlim = c(0.1, 20) , xlab="X", ylab = "Y", col = "red")
curve( W1.3.fun(x, b, d, e), add = T, col = "black" )
curve( W2.3.fun(x, b, d, e), add = T, col = "bluek" )
curve( W2.3.fun(x, b, d, e), add = T, col = "blue" )
d <- 10; c <- 2; e <- 7; b <- 0.5
curve( G4.fun(x, b, c, d, e), xlim = c(0, 20) , xlab="X", ylab = "Y")
curve( L4.fun(x, b, c, d, e), add = T, col = "red" )
curve( E4.fun(x, b, c, d, e), add = T, col = "blue" )
library(drc)
Temp <- c(5, 10, 15, 20, 25, 30, 35, 40, 45, 50)
RGR <- c(0.1, 2, 5.7, 9.3, 19.7, 28.4, 20.3, 6.6, 1.3, 0.1)
plot(RGR ~ Temp, xlim = c(5, 50),
xlab = "Temperature", ylab = "Growth rate")
X <- c(5, 10, 15, 20, 25, 30, 35, 40, 45, 50)
Y1 <- c(0.1, 2, 5.7, 9.3, 19.7, 28.4, 20.3, 6.6, 1.3, 0.1)
Y2 <- Y1 + 2
# nls fit
mod.nls <- nls(RGR ~ NLS.bragg.3(Temp, b, d, e) )
mod.nls2 <- nls(RGR ~ NLS.bragg.4(Temp, b, c, d, e) )
summary(mod.nls)
summary(mod.nls2)
# nls fit
mod.nls <- nls(Y ~ NLS.bragg.3(X, b, d, e) )
# nls fit
mod.nls <- nls(Y1 ~ NLS.bragg.3(X, b, d, e) )
# nls fit
mod.nls <- nls(Y1 ~ NLS.bragg.3(X, b, d, e) )
mod.nls2 <- nls(Y2 ~ NLS.bragg.4(Temp, b, c, d, e) )
# drm fit
mod.drc <- drm(Y1 ~ Temp, fct = DRC.bragg.3() )
mod.drc2 <- drm(Y2 ~ Temp, fct = DRC.bragg.4() )
plot(mod.drc)
plot(mod.drc2, add = T)
plot(mod.drc)
plot(mod.drc2, add = T, col = "red")
plot(mod.drc2)
plot(mod.drc, add = T, col = "red")
plot(mod.drc, ylim = c(0, 30), ), log = "")
plot(mod.drc, ylim = c(0, 30), log = "")
plot(mod.drc2, add = T, col = "red")
?importFrom
??importFrom
library(aomisc)
library(aomisc)
