reg1 <- data[1:pos, ]
reg2 <- data[pos:len, ]
x1 <- reg1[,1]; y1 <- reg1[, 2]
x2 <- reg2[,1]; y2 <- reg2[, 2]
ss1 <- coef( lm(y1 ~ x1) )
ThetaT <- 1/ss1[2]
Tb <- - ss1[1] * ThetaT
ss2 <- coef( lm((1-y2) ~ x2) )
k <- ss2[2]
To <- - ss2[1] / k
Tc <- (1 - ss2[1])/ss2[2]
return(c(Tb, ThetaT, k, Tc))}
deriv1 <- function(x, parm){
#Approximation by using finite differences
d1.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d1.2 <- GRT.Exb.fun(x, (parm[,1] + 10e-6), parm[,2], parm[,3],
parm[,4])
d1 <- (d1.2 - d1.1)/10e-6
d2.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d2.2 <- GRT.Exb.fun(x, parm[,1], (parm[,2] + 10e-6), parm[,3],
parm[,4])
d2 <- (d2.2 - d2.1)/10e-6
d3.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d3.2 <- GRT.Exb.fun(x, parm[,1], parm[,2], (parm[,3] + 10e-6),
parm[,4])
d3 <- (d3.2 - d3.1)/10e-6
d4.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d4.2 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
(parm[,4] + 10e-6))
d4 <- (d4.2 - d4.1)/10e-6
cbind(d1, d2, d3, d4)
}
text <- "Exponential effect of temperature on GR50 (Type II - Masin et al., 2017)"
returnList <- list(fct=fct, ssfct=ss, names=names, text=text, deriv1 = deriv1)
class(returnList) <- "drcMean"
invisible(returnList)
}
#Barley non OK
modNaive <- drm(GRA30 ~ Temp, data=dataset2, fct=GRT.Exb())
plot(modNaive, log="y", type = "all")
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
#Funzione per il calcolo solo con MLE###############################
meta.drm <- function(formula, SE, fct, data){
MLfun <- function(formula, SE, fct, data, parms){
fr <- model.frame(formula, data)
X <- model.matrix(fr, data)[,2]
Y <- model.response(fr, "numeric")
vi <- SE^2
#print(parms[1])
tau <- max(0, parms[1])
totVar <- tau + vi
w <- 1/totVar
parmMat <- matrix(parms[2:length(parms)], 1, length(parms[2:length(parms)]))
expt <- fct$fct(X, parmMat)
res <- Y - expt
#- ( -length(Y)/2*log(2*pi)-1/2*sum(log(totVar))-
#      1/2*sum(res^2/totVar ) )
ll <-  -1/2 * log(2*pi) - 1/2 * log(totVar) - 1/2 * (res^2) / totVar
-sum(ll)
}
vi <- SE^2
naiveMod <- drm(formula, data=data, fct=fct)
MSE <- sum(residuals(naiveMod)^2)/naiveMod$df
tau <- MSE - mean(vi)
tau <- max(0.001, tau)
parms <- c(tau, naiveMod$coef)
#print(fct$deriv1())
names(parms) <- c("tau2", fct$names)
likfun <- optim(par = parms, lower = c(0, rep(NA, length(parms))),
fn = MLfun,
method = "L-BFGS-B", hessian=T,
formula = formula, SE = SE, fct = fct,
data=data)
#Get the necessary infos from optim object
parnames <- c("tau2", fct$names)
parvalues <- as.numeric(likfun$par)
logLik <- likfun$value
vcov <- solve(likfun$hessian)
parSE1 <- as.numeric( sqrt(diag(vcov)) )
#If I do not want to use the hessian to get SEs and
# I do not want to fit a weighted regression I can
X <- fct$deriv1(naiveMod$dataList$dose, t(parvalues[2:length(parvalues)]))
colnames(X) <- fct$names
w <- 1/totVar
W <- diag(w)
vcovMeta <- solve(t(X) %*% W %*% X) %*%
(t(X) %*% W %*% diag(totVar) %*%
t(W) %*% X) %*% solve(t(X) %*% W %*% X)
parSE2 <- as.numeric( sqrt(diag(vcovMeta)) )
parSE2 <- c(parSE1[1], parSE2)
coefficients <- data.frame("Estimate"=parvalues, "SE.ML"= parSE1, "SE2" = parSE2)#, row.names=parnames)
row.names(coefficients) <- c("tau2", fctFit$names)
list("coefficients" = coefficients, "vcov" = vcov, "vcov2" = vcovMeta, "logLik" = logLik)
}
#Barley non OK
modNaive <- drm(GRA30 ~ Temp, data=dataset2, fct=GRT.Exb())
plot(modNaive, log="y", type = "all")
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
#Funzione per il calcolo solo con MLE###############################
meta.drm <- function(formula, SE, fct, data){
MLfun <- function(formula, SE, fct, data, parms){
fr <- model.frame(formula, data)
X <- model.matrix(fr, data)[,2]
Y <- model.response(fr, "numeric")
vi <- SE^2
#print(parms[1])
tau <- max(0, parms[1])
totVar <- tau + vi
w <- 1/totVar
parmMat <- matrix(parms[2:length(parms)], 1, length(parms[2:length(parms)]))
expt <- fct$fct(X, parmMat)
res <- Y - expt
#- ( -length(Y)/2*log(2*pi)-1/2*sum(log(totVar))-
#      1/2*sum(res^2/totVar ) )
ll <-  -1/2 * log(2*pi) - 1/2 * log(totVar) - 1/2 * (res^2) / totVar
-sum(ll)
}
vi <- SE^2
naiveMod <- drm(formula, data=data, fct=fct)
MSE <- sum(residuals(naiveMod)^2)/naiveMod$df
tau <- MSE - mean(vi)
tau <- max(0.001, tau)
parms <- c(tau, naiveMod$coef)
#print(fct$deriv1())
names(parms) <- c("tau2", fct$names)
likfun <- optim(par = parms, lower = c(0, rep(NA, length(parms))),
fn = MLfun,
method = "L-BFGS-B", hessian=T,
formula = formula, SE = SE, fct = fct,
data=data)
#Get the necessary infos from optim object
parnames <- c("tau2", fct$names)
parvalues <- as.numeric(likfun$par)
logLik <- likfun$value
vcov <- solve(likfun$hessian)
parSE1 <- as.numeric( sqrt(diag(vcov)) )
#If I do not want to use the hessian to get SEs and
# I do not want to fit a weighted regression I can
X <- fct$deriv1(naiveMod$dataList$dose, t(parvalues[2:length(parvalues)]))
colnames(X) <- fct$names
totVar <- parvalues[1] + vi
w <- 1/totVar
W <- diag(w)
vcovMeta <- solve(t(X) %*% W %*% X) %*%
(t(X) %*% W %*% diag(totVar) %*%
t(W) %*% X) %*% solve(t(X) %*% W %*% X)
parSE2 <- as.numeric( sqrt(diag(vcovMeta)) )
parSE2 <- c(parSE1[1], parSE2)
coefficients <- data.frame("Estimate"=parvalues, "SE.ML"= parSE1, "SE2" = parSE2)#, row.names=parnames)
row.names(coefficients) <- c("tau2", fctFit$names)
list("coefficients" = coefficients, "vcov" = vcov, "vcov2" = vcovMeta, "logLik" = logLik)
}
#Barley non OK
modNaive <- drm(GRA30 ~ Temp, data=dataset2, fct=GRT.Exb())
plot(modNaive, log="y", type = "all")
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
#Funzione per il calcolo solo con MLE###############################
meta.drm <- function(formula, SE, fct, data){
MLfun <- function(formula, SE, fct, data, parms){
fr <- model.frame(formula, data)
X <- model.matrix(fr, data)[,2]
Y <- model.response(fr, "numeric")
vi <- SE^2
#print(parms[1])
tau <- max(0, parms[1])
totVar <- tau + vi
w <- 1/totVar
parmMat <- matrix(parms[2:length(parms)], 1, length(parms[2:length(parms)]))
expt <- fct$fct(X, parmMat)
res <- Y - expt
#- ( -length(Y)/2*log(2*pi)-1/2*sum(log(totVar))-
#      1/2*sum(res^2/totVar ) )
ll <-  -1/2 * log(2*pi) - 1/2 * log(totVar) - 1/2 * (res^2) / totVar
-sum(ll)
}
vi <- SE^2
naiveMod <- drm(formula, data=data, fct=fct)
MSE <- sum(residuals(naiveMod)^2)/naiveMod$df
tau <- MSE - mean(vi)
tau <- max(0.001, tau)
parms <- c(tau, naiveMod$coef)
#print(fct$deriv1())
names(parms) <- c("tau2", fct$names)
likfun <- optim(par = parms, lower = c(0, rep(NA, length(parms))),
fn = MLfun,
method = "L-BFGS-B", hessian=T,
formula = formula, SE = SE, fct = fct,
data=data)
#Get the necessary infos from optim object
parnames <- c("tau2", fct$names)
parvalues <- as.numeric(likfun$par)
logLik <- likfun$value
vcov <- solve(likfun$hessian)
parSE1 <- as.numeric( sqrt(diag(vcov)) )
#If I do not want to use the hessian to get SEs and
# I do not want to fit a weighted regression I can
X <- fct$deriv1(naiveMod$dataList$dose, t(parvalues[2:length(parvalues)]))
colnames(X) <- fct$names
totVar <- parvalues[1] + vi
w <- 1/totVar
W <- diag(w)
vcovMeta <- solve(t(X) %*% W %*% X) %*%
(t(X) %*% W %*% diag(totVar) %*%
t(W) %*% X) %*% solve(t(X) %*% W %*% X)
parSE2 <- as.numeric( sqrt(diag(vcovMeta)) )
parSE2 <- c(parSE1[1], parSE2)
coefficients <- data.frame("Estimate"=parvalues, "SE.ML"= parSE1, "SE2" = parSE2)#, row.names=parnames)
row.names(coefficients) <- c("tau2", fct$names)
list("coefficients" = coefficients, "vcov" = vcov, "vcov2" = vcovMeta, "logLik" = logLik)
}
#Barley non OK
modNaive <- drm(GRA30 ~ Temp, data=dataset2, fct=GRT.Exb())
plot(modNaive, log="y", type = "all")
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
modMeta$coef
summary(modNaive)
rm(list=ls())
library(metafor)
library(drc)
source("myFun.R")
step2Data <- read.csv("step2DataSeed.csv", header=T)
head(step2Data)
ts.mm <-rma(ED50, (SE)^2, mods = ~ Temp, data = step2Data, method="HE")
ts.mm$tau2
summary(ts.mm)
ts.mm2 <-rma(ED50, (SE)^2, mods = ~ Temp, data = step2Data, method="ML")
myMetafor(step2Data$ED50, step2Data$SE^2, mods = ~ Temp, step2Data, method="ML")
ts.mm2$se
vcov(ts.mm2)
#Can we do the same with drc?
res <- meta.drm(ED50 ~ Temp, step2Data$SE, fct=DRC.linear(), step2Data)
res$coef
ts.mm2
res$coef
res$vcov
res$vcov2
rm(list=ls())
source("myFun.R")
library(drcSeedGerm)
library(drc)
dataset <- read.csv("step2Barley.csv", header=T)
head(dataset)
plot(GRA30 ~ Temp, data = dataset)
dataset2 <- subset(dataset, Temp < 35)
#Barley non OK
modNaive <- drm(GRA30 ~ Temp, data=dataset2, fct=GRT.Exb())
plot(modNaive, log="y", type = "all")
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
# Exponential with switch-off (From Masin et al., 2017 - modified)
GRT.Exb.fun <- function(Temp, Tb, ThetaT, k, Tc) {
GR50 <- ((Temp - Tb)/ThetaT) * ((1 - exp(k * (Temp - Tc)))/(1 - exp(k * (Tb - Tc))))
return(ifelse(GR50 < 0 , 0 , GR50)) }
"GRT.Exb" <- function(){
fct <- function(x, parm) {
GR50 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3], parm[,4])
return(GR50) }
names <- c("Tb", "ThetaT", "k", "Tc")
ss <- function(data){
pos <- which( data[,2]==max(data[,2]) )
len <- length( data[,2] )
reg1 <- data[1:pos, ]
reg2 <- data[pos:len, ]
x1 <- reg1[,1]; y1 <- reg1[, 2]
x2 <- reg2[,1]; y2 <- reg2[, 2]
ss1 <- coef( lm(y1 ~ x1) )
ThetaT <- 1/ss1[2]
Tb <- - ss1[1] * ThetaT
ss2 <- coef( lm((1-y2) ~ x2) )
k <- ss2[2]
To <- - ss2[1] / k
Tc <- (1 - ss2[1])/ss2[2]
return(c(Tb, ThetaT, k, Tc))}
deriv1 <- function(x, parm){
#Approximation by using finite differences
d1.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d1.2 <- GRT.Exb.fun(x, (parm[,1] + 10e-6), parm[,2], parm[,3],
parm[,4])
d1 <- (d1.2 - d1.1)/10e-6
d2.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d2.2 <- GRT.Exb.fun(x, parm[,1], (parm[,2] + 10e-6), parm[,3],
parm[,4])
d2 <- (d2.2 - d2.1)/10e-6
d3.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d3.2 <- GRT.Exb.fun(x, parm[,1], parm[,2], (parm[,3] + 10e-6),
parm[,4])
d3 <- (d3.2 - d3.1)/10e-6
d4.1 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
parm[,4])
d4.2 <- GRT.Exb.fun(x, parm[,1], parm[,2], parm[,3],
(parm[,4] + 10e-6))
d4 <- (d4.2 - d4.1)/10e-6
cbind(d1, d2, d3, d4)
}
text <- "Exponential effect of temperature on GR50 (Type II - Masin et al., 2017)"
returnList <- list(fct=fct, ssfct=ss, names=names, text=text, deriv1 = deriv1)
class(returnList) <- "drcMean"
invisible(returnList)
}
modMeta <- meta.drm(GRA30 ~ Temp, dataset2$SEGR30, fct=GRT.Exb(), dataset2)
summary(modNaive)
modMeta$coef
#Tarof
dataset <- read.csv("step2Tarof.csv", header=T)
head(dataset)
#From Mesgaran et al., 2017
GRT.M.fun <- function(predictor, Tc, Tb, ThetaT) {
Temp <- predictor
t2 <- ifelse(Temp < Tb, Tb, Temp)
psival <- ifelse(1 - (Temp - Tb)/(Tc - Tb) > 0, 1 - (Temp - Tb)/(Tc - Tb), 0)
GR <- psival * (t2 - Tb)/ThetaT
return(ifelse(GR < 0 , 0 , GR)) }
modNaive <- drm(GR30 ~ Temp, data=dataset, fct=GRT.M())
plot(modNaive, log="", type="all", xlim=c(0,30), ylim=c(0,0.3))
summary(modNaive)
modMeta <- meta.drm(GR30 ~ Temp, dataset$ES, fct=GRT.M(), dataset)
modMeta$coefficients
summary(modNaive)
"DRC.poly2" <- function(fixed = c(NA, NA, NA), names = c("a", "b", "c"))
{
## Checking arguments
numParm <- 3
if (!is.character(names) | !(length(names) == numParm)) {stop("Not correct 'names' argument")}
if (!(length(fixed) == numParm)) {stop("Not correct 'fixed' argument")}
## Fixing parameters (using argument 'fixed')
notFixed <- is.na(fixed)
parmVec <- rep(0, numParm)
parmVec[!notFixed] <- fixed[!notFixed]
## Defining the non-linear function
fct <- function(x, parm)
{
parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)
parmMat[, notFixed] <- parm
a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]
a + b * x + c * (x^2)
}
## Defining self starter function
ssfct <- function(dataf)
{
x <- dataf[, 1]
y <- dataf[, 2]
#regression on pseudo y values
pseudoY <- y
pseudoX <- x
coefs <- coef( lm(pseudoY ~ pseudoX + I(pseudoX^2)) )
a <- coefs[1]
b <- coefs[2]
c <- coefs[3]
return(c(a, b, c)[notFixed])
}
## Defining names
pnames <- names[notFixed]
## Defining derivatives
deriv1 <- function(x, parm){
d1 <- rep(1, length(x) )
d2 <- x
d3 <- x^2
cbind(d1, d2, d3)
}
## Defining the ED function
## Defining the inverse function
## Defining descriptive text
text <- "Second Order Polynomial"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))
class(returnList) <- "drcMean"
invisible(returnList)
}
modNaive <- drm(GR30 ~ Temp, data=dataset, fct=DRC.poly2())
plot(modNaive, log="", type="all")
summary(modNaive)
modMeta <- meta.drm(GR30 ~ Temp, dataset$EST, fct=DRC.poly2(), dataset)
#Poly2 ##############################################
poly2.fun <- function(predictor, b) {
a + b * predictor + c * (predictor^2)
}
poly2.Init <- function(mCall, LHS, data) {
xy <- sortedXyData(mCall[["predictor"]], LHS, data)
lmFit <- lm((xy[, "y"]) ~ xy[, "x"] + I( xy[, "x"]^2))
coefs <- coef(lmFit)
a <- coefs[1]
b <- coefs[2]
c <- coefs[3]
value <- c(a, b, c)
names(value) <- mCall[c("a", "b", "c")]
value
}
NLS.poly2 <- selfStart(poly2.fun, poly2.Init, parameters=c("a", "b", "c"))
"DRC.poly2" <- function(fixed = c(NA, NA, NA), names = c("a", "b", "c"))
{
## Checking arguments
numParm <- 3
if (!is.character(names) | !(length(names) == numParm)) {stop("Not correct 'names' argument")}
if (!(length(fixed) == numParm)) {stop("Not correct 'fixed' argument")}
## Fixing parameters (using argument 'fixed')
notFixed <- is.na(fixed)
parmVec <- rep(0, numParm)
parmVec[!notFixed] <- fixed[!notFixed]
## Defining the non-linear function
fct <- function(x, parm)
{
parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)
parmMat[, notFixed] <- parm
a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]
a + b * x + c * (x^2)
}
## Defining self starter function
ssfct <- function(dataf)
{
x <- dataf[, 1]
y <- dataf[, 2]
#regression on pseudo y values
pseudoY <- y
pseudoX <- x
coefs <- coef( lm(pseudoY ~ pseudoX + I(pseudoX^2)) )
a <- coefs[1]
b <- coefs[2]
c <- coefs[3]
return(c(a, b, c)[notFixed])
}
## Defining names
pnames <- names[notFixed]
## Defining derivatives
deriv1 <- function(x, parm){
d1 <- rep(1, length(x) )
d2 <- x
d3 <- x^2
cbind(d1, d2, d3)
}
## Defining the ED function
## Defining the inverse function
## Defining descriptive text
text <- "Second Order Polynomial"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))
class(returnList) <- "drcMean"
invisible(returnList)
}
modMeta <- meta.drm(GR30 ~ Temp, dataset$EST, fct=DRC.poly2(), dataset)
DRC.poly2
"DRC.poly2" <- function(fixed = c(NA, NA, NA), names = c("a", "b", "c"))
{
## Checking arguments
numParm <- 3
if (!is.character(names) | !(length(names) == numParm)) {stop("Not correct 'names' argument")}
if (!(length(fixed) == numParm)) {stop("Not correct 'fixed' argument")}
## Fixing parameters (using argument 'fixed')
notFixed <- is.na(fixed)
parmVec <- rep(0, numParm)
parmVec[!notFixed] <- fixed[!notFixed]
## Defining the non-linear function
fct <- function(x, parm)
{
parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)
parmMat[, notFixed] <- parm
a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]
a + b * x + c * (x^2)
}
## Defining self starter function
ssfct <- function(dataf)
{
x <- dataf[, 1]
y <- dataf[, 2]
#regression on pseudo y values
pseudoY <- y
pseudoX <- x
coefs <- coef( lm(pseudoY ~ pseudoX + I(pseudoX^2)) )
a <- coefs[1]
b <- coefs[2]
c <- coefs[3]
return(c(a, b, c)[notFixed])
}
## Defining names
pnames <- names[notFixed]
## Defining derivatives
deriv1 <- function(x, parm){
d1 <- rep(1, length(x) )
d2 <- x
d3 <- x^2
cbind(d1, d2, d3)
}
## Defining the ED function
## Defining the inverse function
## Defining descriptive text
text <- "Second Order Polynomial"
## Returning the function with self starter and names
returnList <- list(fct = fct, ssfct = ssfct, names = pnames,
text = text, noParm = sum(is.na(fixed)), deriv1 = deriv1)
class(returnList) <- "drcMean"
invisible(returnList)
}
modMeta <- meta.drm(GR30 ~ Temp, dataset$EST, fct=DRC.poly2(), dataset)
modMeta$coef
ts.mm <-rma(T30, EST^2, mods = ~ Temp + I(Temp^2), data = dataset, method="ML")
ts.mm
modMeta$coef
ts.mm2 <-rma(GR30, EST^2, mods = ~ Temp + I(Temp^2), data = dataset, method="ML")
ts.mm2
modMeta$coef
modMeta <- meta.drm(GR30 ~ Temp, dataset$EST, fct=DRC.poly2(), dataset)
modMeta$coef
ts.mm2 <-rma(GR30, EST^2, mods = ~ Temp + I(Temp^2), data = dataset, method="ML")
ts.mm2
modNaive <- drm(GR30 ~ Temp, data=dataset, fct=DRC.poly2())
plot(modNaive, log="", type="all")
summary(modNaive)
