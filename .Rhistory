func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
#Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
vcovC <- vcov(obj)
temp <- ~k1 - k2
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcovC, level = 0.95))
lisRes
val <- ldply(lisRes)
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
val
gnlht <- function(obj, func,  const = NULL){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
vcovC <- vcov(obj)
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcovC, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcovC, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
funList <- data.frame(form = c("k1 - k2", "k1 - k3", "k1 - k4"))
gnlht(modNlin, funList)
funList <- data.frame(form = c(~k1 - k2, ~k1 - k3, ~k1 - k4))
funList <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
if (is.function(vcov.))
vcMat <- vcov.(object, ...)
else vcMat <- vcov.
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
funList <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
print(str(vcov.))
if (is.function(vcov.))
vcMat <- vcov.(object, ...)
else vcMat <- vcov.
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
funList <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(object)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
return(val)
}
funList <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
?drm
str(funList)
funList <- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
return(retDF)
}
gnlht(modNlin, funList)
m1 <- c(rep(0, 4), 1, -1, 0, 0)
m2 <- c(rep(0, 4), 1, 0, -1, 0)
m3 <- c(rep(0, 4), 1, 0, 0, -1)
m4 <- c(rep(0, 4), 0, 1, -1, 0)
m5 <- c(rep(0, 4), 0, 1, 0, -1)
m6 <- c(rep(0, 4), 0, 0, 1, -1)
k <- matrix(c(m1,m2,m3,m4,m5,m6),6,8, byrow=T)
mc <- glht(modNlin, linfct=k)
library(multcomp)
k <- matrix(c(m1,m2,m3,m4,m5,m6),6,8, byrow=T)
mc <- glht(modNlin, linfct=k)
summary(mc, test=adjusted(type="none"))
modDrm <- drm(Conc ~ Tempo, data = metamitron, fct = DRC.expoDecay(),
curveid = Tesi)
summary(modDrm)
modDrm <- drm(Conc ~ Tempo, data = metamitron, fct = DRC.expoDecay(),
curveid = Tesi)
modDrm <- drm(Conc ~ Time, data = metamitron, fct = DRC.expoDecay(),
curveid = Herbicide)
summary(modDrm)
compParm(modDrm, strVal = "k", operator = "-")
#Differences between parameters (no constants)
funList <- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht(modDrm, funList)
summary(modDrm)
library(car)
?deltaMethod
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
return(retDF)
}
gnlht(modNlin, funList, parameterNames = names(coef(modNlin)) )
compParm(modDrm, strVal = "k", operator = "-")
gnlht(modDrm, funList, parameterNames = names(coef(modNlin)) )
suma <- summary(modNlin)
suma$df
suma2 <- summary(modDrm)
suma2$df.residual
class(modDrm)
class(modNlin)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
retDF$"t-value" <- retDF$Estimate/retDF$SE
if(class(obj) == "nls") resDF <- summary(obj)$df[2]
else if(class(obj) == "drc") resDF <- summary(obj)$df
else resDF <- Inf
retDF$"p-value" <- pt(retDF$"t-value", resDF)
return(retDF)
}
gnlht(modNlin, funList)
gnlht(modDrm, funList, parameterNames = names(coef(modNlin)) )
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
retDF$"t-value" <- retDF$Estimate/retDF$SE
if(class(obj) == "nls") resDF <- summary(obj)$df[2]
else if(class(obj) == "drc") resDF <- summary(obj)$df
else resDF <- Inf
retDF$"p-value" <- pt(retDF$"t-value", resDF, lower.tail = F)
return(retDF)
}
#Differences between parameters (no constants)
funList <- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht(modDrm, funList, parameterNames = names(coef(modNlin)) )
compParm(modDrm, strVal = "k", operator = "-")
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
retDF$"t-value" <- retDF$Estimate/retDF$SE
if(class(obj) == "nls") resDF <- summary(obj)$df[2]
else if(class(obj) == "drc") resDF <- summary(obj)$df
else resDF <- Inf
retDF$"p-value" <- 2 * pt(retDF$"t-value", resDF, lower.tail = F)
return(retDF)
}
compParm(modDrm, strVal = "k", operator = "-")
#Differences between parameters (no constants)
funList <- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
retDF$"t-value" <- retDF$Estimate/retDF$SE
if(class(obj) == "nls") resDF <- summary(obj)$df[2]
else if(class(obj) == "drc") resDF <- summary(obj)$df
else resDF <- Inf
retDF$"p-value" <- 0.5 * pt(retDF$"t-value", resDF, lower.tail = F)
return(retDF)
}
gnlht(modNlin, funList)
gnlht <- function(obj, func,  const = NULL, vcov. = vcov, parameterNames=names(coef(obj))){
# obj <- modNlin
# func <- c(~k1 - k2, ~k1 - k3, ~k1 - k4)
# Da qui
temp <- lapply(func, function(x) as.character(as.expression(x[[length(x)]])))
func <- data.frame(form=unlist(temp))
coefs <- coef(obj)
names(coefs) <- parameterNames
#print(str(vcov.))
if (is.function(vcov.)){
vcMat <- vcov.(obj)
} else {vcMat <- vcov.}
# const <- constList; func <- funList
# print(is.null(const))
if(is.null(const) == T){
lisRes <- apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95))
val <- plyr::ldply(lisRes)
val <- cbind(func, val)
}else{
lisRes <- apply(const, 1, function(y) apply(func, 1,
function(x) car::deltaMethod(object=coefs, g=x,
vcov.=vcMat, level = 0.95, constants = y )))
val <- ldply(do.call(rbind, lisRes))
funList <- func %>% slice(rep(1:n(), each = length(const[,1])))
constList <- const %>% slice(rep(1:n(), length(func[,1])))
val <- cbind(funList, constList, val)
}
retDF <- val[,1:3]
retDF$"t-value" <- retDF$Estimate/retDF$SE
if(class(obj) == "nls") resDF <- summary(obj)$df[2]
else if(class(obj) == "drc") resDF <- summary(obj)$df
else resDF <- Inf
print(resDF)
retDF$"p-value" <- 2 * pt(retDF$"t-value", resDF, lower.tail = F)
return(retDF)
}
#Differences between parameters (no constants)
funList <- list(~k1 - k2, ~k1 - k3, ~k1 - k4)
gnlht(modNlin, funList)
gnlht(modDrm, funList, parameterNames = names(coef(modNlin)) )
compParm(modDrm, strVal = "k", operator = "-")
