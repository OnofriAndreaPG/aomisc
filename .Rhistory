{
################################################################################
boxcoxCI <- function(x, y, level = 0.95){
## R lines taken from boxcox.default in the package MASS and then
# slightly modified
xl <- x
loglik <- y
llnotna <- !is.na(loglik)
xl <- xl[llnotna]
loglik <- loglik[llnotna]
m <- length(loglik)
mx <- (1:m)[loglik == max(loglik)][1]
Lmax <- loglik[mx]
lim <- Lmax - qchisq(level, 1)/2
ind <- range((1:m)[loglik > lim])
xx <- rep(NA, 2)
if(loglik[1] < lim)
{
i <- ind[1]
xx[1] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
if(loglik[m] < lim)
{
i <- ind[2] + 1
xx[2] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
return(xx)
}
##################################################################################
if(is.null(bcVal) == F) plotit = F
if(is.data.frame(eval(object$data)) == F){
stop("boxcox.nls() works only when a dataframe is passed to the nls call")
}
bfFct <- function(lv)
{
function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
}
evalForm <- eval(formula(object)[[3]][[1]])
bfFct2 <- function(lv)
{
bcFct2 <- function(x)
{
## Transforming the mean
bcFct <- bfFct(lv)
bcFctVal <- bcFct(x)
## Adjusting gradient
grad1 <- attr(bcFctVal, "gradient")
grad2 <- grad1*(x^(lv-1))
attr(bcFctVal, "gradient") <- grad2
bcFctVal
}
bcFct2
}
if (!inherits(evalForm , "selfStart"))
{
bfFct2 <- bfFct
}
#    bcFct <- function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
#    assign("bcFct", bcFct, envir = .GlobalEnv)
#    newFormula <- bcFct(.) ~ bcFct(.)
if (missing(start))
{
startVec <- coef(object)
} else {
startVec <- start
}
## Defining the log-likelihood function
llFct <- function(object, lv)
{
# print(object$data)
# stop()
#sumObj <- summary(object)
#N <- sum(sumObj$df)
N <- length(eval(object$data)[,1])
Ji <- (eval(object$data)[, as.character(formula(object)[[2]])[2]])^(lv-1)
-N*log(sqrt(sum(residuals(object)^2)/N))-N/2+sum(log(Ji))
}
#print(bcVal)
if(is.null(bcVal) == T){
lenlam <- length(lambda)
llVec <- rep(NA, lenlam)
} else {
lenlam <- 1
llVec <- rep(NA, lenlam)
lambda <- bcVal
}
for (i in 1:lenlam)
{
#        lv <- lambda[i]
#        assign("bcFct", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct1", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct2", bfFct2(lambda[i]), envir = .GlobalEnv)
newFormula <- bcFct1(.) ~ bcFct2(.)
nlsTemp <- try(update(object, formula. = newFormula, start = startVec, trace = FALSE), silent = TRUE)
if (!inherits(nlsTemp, "try-error")) {llVec[i] <- llFct(nlsTemp, lambda[i])}
}
lv <- lambda[which.max(llVec)]
llv <- max(llVec, na.rm = TRUE)
ci <- boxcoxCI(lambda, llVec, level)
if (plotit)  # based on boxcox.default
{
plot(lambda, llVec, type ="l", xlab = xlab, ylab = ylab, ...)
plims <- par("usr")
y0 <- plims[3]
lim <- llv-qchisq(level, 1)/2
segments(lv, llv, lv, y0, lty=3)
segments(ci[1], lim, ci[1], y0, lty = 3)  # lower limit
segments(ci[2], lim, ci[2], y0, lty = 3)  # upper limit
scal <- (1/10 * (plims[4] - y0))/par("pin")[2]
scx <- (1/10 * (plims[2] - plims[1]))/par("pin")[1]
text(lambda[1] + scx, lim + scal, " 95%")
abline(h = lim, lty = 3)
}
# #    assign("bcFct", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct1", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct2", bfFct2(lv), envir = .GlobalEnv)
# retFit <- update(object, formula. = newFormula, start = startVec, trace = FALSE)
# # last time 'bcFct1' and 'bcFct2' are used
rm(bcFct1, bcFct2, envir = .GlobalEnv)  # to ensure that the predict method can find bcFct2()
# retFit$lambda <- list(lambda = lv, ci = ci)
# invisible(retFit)
}
"bcSummary" <- function(object)
{
cat("\n")
cat("Estimated lambda:", object$lambda$lambda, "\n")
bcci <- format(object$lambda$ci, digits = 2)
ciStr <- paste("[", bcci[1], ",", bcci[2], "]", sep="")
cat("Confidence interval for lambda:", ciStr, "\n\n")
}
data("degradation")
model <- drm(Conc ~ Time, fct = DRC.expoDecay(),
data = degradation)
summary(model)
model2 <- nls(Conc ~ NLS.expoDecay(Time, a, c),
data = degradation)
summary(model2)
boxcox(model)
model2 <- nls(Conc ~ NLS.expoDecay(Time, a, c),
data = degradation)
summary(model2)
boxcox(model2)
"boxcox.nls" <- function(object, lambda = seq(-2, 2, 1/10), plotit = TRUE, start,
eps = 1/50, bcAdd = 0, level = 0.95, bcVal = NULL,
xlab = expression(lambda), ylab = "log-likelihood", ...)
{
################################################################################
boxcoxCI <- function(x, y, level = 0.95){
## R lines taken from boxcox.default in the package MASS and then
# slightly modified
xl <- x
loglik <- y
llnotna <- !is.na(loglik)
xl <- xl[llnotna]
loglik <- loglik[llnotna]
m <- length(loglik)
mx <- (1:m)[loglik == max(loglik)][1]
Lmax <- loglik[mx]
lim <- Lmax - qchisq(level, 1)/2
ind <- range((1:m)[loglik > lim])
xx <- rep(NA, 2)
if(loglik[1] < lim)
{
i <- ind[1]
xx[1] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
if(loglik[m] < lim)
{
i <- ind[2] + 1
xx[2] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
return(xx)
}
##################################################################################
if(is.null(bcVal) == F) plotit = F
if(is.data.frame(eval(object$data)) == F){
stop("boxcox.nls() works only when a dataframe is passed to the nls call")
}
bfFct <- function(lv)
{
function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
}
evalForm <- eval(formula(object)[[3]][[1]])
bfFct2 <- function(lv)
{
bcFct2 <- function(x)
{
## Transforming the mean
bcFct <- bfFct(lv)
bcFctVal <- bcFct(x)
## Adjusting gradient
grad1 <- attr(bcFctVal, "gradient")
grad2 <- grad1*(x^(lv-1))
attr(bcFctVal, "gradient") <- grad2
bcFctVal
}
bcFct2
}
if (!inherits(evalForm , "selfStart"))
{
bfFct2 <- bfFct
}
#    bcFct <- function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
#    assign("bcFct", bcFct, envir = .GlobalEnv)
#    newFormula <- bcFct(.) ~ bcFct(.)
if (missing(start))
{
startVec <- coef(object)
} else {
startVec <- start
}
## Defining the log-likelihood function
llFct <- function(object, lv)
{
# print(object$data)
# stop()
#sumObj <- summary(object)
#N <- sum(sumObj$df)
N <- length(eval(object$data)[,1])
Ji <- (eval(object$data)[, as.character(formula(object)[[2]])[2]])^(lv-1)
-N*log(sqrt(sum(residuals(object)^2)/N))-N/2+sum(log(Ji))
}
#print(bcVal)
if(is.null(bcVal) == T){
lenlam <- length(lambda)
llVec <- rep(NA, lenlam)
} else {
lenlam <- 1
llVec <- rep(NA, lenlam)
lambda <- bcVal
}
for (i in 1:lenlam)
{
#        lv <- lambda[i]
#        assign("bcFct", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct1", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct2", bfFct2(lambda[i]), envir = .GlobalEnv)
newFormula <- bcFct1(.) ~ bcFct2(.)
nlsTemp <- try(update(object, formula. = newFormula, start = startVec, trace = FALSE), silent = TRUE)
if (!inherits(nlsTemp, "try-error")) {llVec[i] <- llFct(nlsTemp, lambda[i])}
}
lv <- lambda[which.max(llVec)]
llv <- max(llVec, na.rm = TRUE)
ci <- boxcoxCI(lambda, llVec, level)
if (plotit)  # based on boxcox.default
{
plot(lambda, llVec, type ="l", xlab = xlab, ylab = ylab, ...)
plims <- par("usr")
y0 <- plims[3]
lim <- llv-qchisq(level, 1)/2
segments(lv, llv, lv, y0, lty=3)
segments(ci[1], lim, ci[1], y0, lty = 3)  # lower limit
segments(ci[2], lim, ci[2], y0, lty = 3)  # upper limit
scal <- (1/10 * (plims[4] - y0))/par("pin")[2]
scx <- (1/10 * (plims[2] - plims[1]))/par("pin")[1]
text(lambda[1] + scx, lim + scal, " 95%")
abline(h = lim, lty = 3)
}
# #    assign("bcFct", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct1", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct2", bfFct2(lv), envir = .GlobalEnv)
# retFit <- update(object, formula. = newFormula, start = startVec, trace = FALSE)
# # last time 'bcFct1' and 'bcFct2' are used
rm(bcFct1, bcFct2, envir = .GlobalEnv)  # to ensure that the predict method can find bcFct2()
# retFit$lambda <- list(lambda = lv, ci = ci)
# invisible(retFit)
cat("\n")
cat("Estimated lambda:", lv, "\n")
bcci <- format(ci, digits = 2)
ciStr <- paste("[", bcci[1], ",", bcci[2], "]", sep="")
cat("Confidence interval for lambda:", ciStr, "\n\n")
}
"bcSummary" <- function(object)
{
cat("\n")
cat("Estimated lambda:", object$lambda$lambda, "\n")
bcci <- format(object$lambda$ci, digits = 2)
ciStr <- paste("[", bcci[1], ",", bcci[2], "]", sep="")
cat("Confidence interval for lambda:", ciStr, "\n\n")
}
boxcox(model2)
p <- boxcox(model2)
p
#Negative exponential function
rm(list=ls())
"boxcox.nls" <- function(object, lambda = seq(-2, 2, 1/10), plotit = TRUE, start,
eps = 1/50, bcAdd = 0, level = 0.95, bcVal = NULL,
xlab = expression(lambda), ylab = "log-likelihood", ...)
{
################################################################################
boxcoxCI <- function(x, y, level = 0.95){
## R lines taken from boxcox.default in the package MASS and then
# slightly modified
xl <- x
loglik <- y
llnotna <- !is.na(loglik)
xl <- xl[llnotna]
loglik <- loglik[llnotna]
m <- length(loglik)
mx <- (1:m)[loglik == max(loglik)][1]
Lmax <- loglik[mx]
lim <- Lmax - qchisq(level, 1)/2
ind <- range((1:m)[loglik > lim])
xx <- rep(NA, 2)
if(loglik[1] < lim)
{
i <- ind[1]
xx[1] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
if(loglik[m] < lim)
{
i <- ind[2] + 1
xx[2] <- xl[i - 1] + ((lim - loglik[i - 1]) *
(xl[i] - xl[i - 1]))/(loglik[i] - loglik[i - 1])
}
return(xx)
}
##################################################################################
if(is.null(bcVal) == F) plotit = F
if(is.data.frame(eval(object$data)) == F){
stop("boxcox.nls() works only when a dataframe is passed to the nls call")
}
bfFct <- function(lv)
{
function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
}
evalForm <- eval(formula(object)[[3]][[1]])
bfFct2 <- function(lv)
{
bcFct2 <- function(x)
{
## Transforming the mean
bcFct <- bfFct(lv)
bcFctVal <- bcFct(x)
## Adjusting gradient
grad1 <- attr(bcFctVal, "gradient")
grad2 <- grad1*(x^(lv-1))
attr(bcFctVal, "gradient") <- grad2
bcFctVal
}
bcFct2
}
if (!inherits(evalForm , "selfStart"))
{
bfFct2 <- bfFct
}
#    bcFct <- function(x) {if (abs(lv) < eps) {return(log(x+bcAdd))} else {return(((x+bcAdd)^lv-1)/lv)}}
#    assign("bcFct", bcFct, envir = .GlobalEnv)
#    newFormula <- bcFct(.) ~ bcFct(.)
if (missing(start))
{
startVec <- coef(object)
} else {
startVec <- start
}
## Defining the log-likelihood function
llFct <- function(object, lv)
{
# print(object$data)
# stop()
#sumObj <- summary(object)
#N <- sum(sumObj$df)
N <- length(eval(object$data)[,1])
Ji <- (eval(object$data)[, as.character(formula(object)[[2]])[2]])^(lv-1)
-N*log(sqrt(sum(residuals(object)^2)/N))-N/2+sum(log(Ji))
}
#print(bcVal)
if(is.null(bcVal) == T){
lenlam <- length(lambda)
llVec <- rep(NA, lenlam)
} else {
lenlam <- 1
llVec <- rep(NA, lenlam)
lambda <- bcVal
}
for (i in 1:lenlam)
{
#        lv <- lambda[i]
#        assign("bcFct", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct1", bfFct(lambda[i]), envir = .GlobalEnv)
assign("bcFct2", bfFct2(lambda[i]), envir = .GlobalEnv)
newFormula <- bcFct1(.) ~ bcFct2(.)
nlsTemp <- try(update(object, formula. = newFormula, start = startVec, trace = FALSE), silent = TRUE)
if (!inherits(nlsTemp, "try-error")) {llVec[i] <- llFct(nlsTemp, lambda[i])}
}
lv <- lambda[which.max(llVec)]
llv <- max(llVec, na.rm = TRUE)
ci <- boxcoxCI(lambda, llVec, level)
if (plotit)  # based on boxcox.default
{
plot(lambda, llVec, type ="l", xlab = xlab, ylab = ylab, ...)
plims <- par("usr")
y0 <- plims[3]
lim <- llv-qchisq(level, 1)/2
segments(lv, llv, lv, y0, lty=3)
segments(ci[1], lim, ci[1], y0, lty = 3)  # lower limit
segments(ci[2], lim, ci[2], y0, lty = 3)  # upper limit
scal <- (1/10 * (plims[4] - y0))/par("pin")[2]
scx <- (1/10 * (plims[2] - plims[1]))/par("pin")[1]
text(lambda[1] + scx, lim + scal, " 95%")
abline(h = lim, lty = 3)
}
# #    assign("bcFct", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct1", bfFct(lv), envir = .GlobalEnv)
# assign("bcFct2", bfFct2(lv), envir = .GlobalEnv)
# retFit <- update(object, formula. = newFormula, start = startVec, trace = FALSE)
# # last time 'bcFct1' and 'bcFct2' are used
rm(bcFct1, bcFct2, envir = .GlobalEnv)  # to ensure that the predict method can find bcFct2()
# retFit$lambda <- list(lambda = lv, ci = ci)
# invisible(retFit)
cat("\n")
cat("Estimated lambda:", lv, "\n")
bcci <- format(ci, digits = 2)
ciStr <- paste("[", bcci[1], ",", bcci[2], "]", sep="")
cat("Confidence interval for lambda:", ciStr, "\n\n")
}
set.seed(1234)
X <- c(1, 3, 5, 7, 9, 11, 13, 20)
a <- 20; c <- 0.3
Ye <- negExp.fun(X, a, c)
epsilon <- rnorm(8, 0, 0.5)
Y <- Ye + epsilon
model <- drm(Y ~ X, fct = DRC.negExp())
summary(model)
plot(model, log="")
boxcox(model)
mod <- lm(Y ~ X)
p <- boxcox(mod)
p
model <- nls(Y ~ NLS.negExp(X, a, c))
summary(model)
plotnls(model, log="")
boxcox(model)
dataset <- data.frame(X, Y)
rm(X, Y)
rm(X, Y, Ye, epsilon, a, c)
model <- nls(Y ~ NLS.negExp(X, a, c), data = dataset)
boxcox(model)
model <- drm(Y ~ X, fct = DRC.negExp())
summary(model)
plot(model, log="")
boxcox(model)
model <- drm(Y ~ X, fct = DRC.negExp())
library(aomisc)
# Exponential decay
rm(list=ls())
data("degradation")
model <- drm(Conc ~ Time, fct = DRC.expoDecay(),
data = degradation)
summary(model)
boxcox(model)
model2 <- nls(Conc ~ NLS.expoDecay(Time, a, c),
data = degradation)
summary(model2)
boxcox(model2)
model2 <- nls(log(Conc) ~ log(NLS.expoDecay(Time, a, c)),
data = degradation)
model2 <- nls(log(Conc) ~ log(NLS.expoDecay(Time, a, c)),
data = degradation, start = coef(model2))
summary(model2)
plotnls(model2)
model2 <- nls(Conc^0.5 ~ NLS.expoDecay(Time, a, c)^0.5,
data = degradation, start = coef(model2))
summary(model2)
plotnls(model2)
model2 <- nls(Conc^0.5 ~ NLS.expoDecay(Time, a, c)^0.5,
data = degradation, start = coef(model2))
summary(model2)
plotnls(model2)
plotnls(model2)
model2 <- nls(Conc^0.5 ~ NLS.expoDecay(Time, a, c)^0.5,
data = degradation, start = coef(model2))
model2 <- nls(log(Conc) ~ log(NLS.expoDecay(Time, a, c)),
data = degradation, start = coef(model2))
plotnls(model2)
library(aomisc)
?BC
??BC
# Brain-Cousens model for hormesis
BC.5.fun <- function(predictor, b, c, d, e, f) {
x <- predictor
c + (d - c)/(1 + exp(-b * (log(x + 0.00001) - log(e))))
}
library(aomisc)
library(aomisc)
beta.fun <- function(X, a, b, c, d){
ifelse(X > b & X < d,
(((X - b)/(c - b) * (d - X)/(d - c))^((d - c)/(c - b)))^a,
0)
}
# Bragg's equation
bragg.fun <- function(X, b, c, d){
b * exp(- b * (X - d)^2)
}
library(devtools)
install.packages("testthat")
library(dplyr)
?ldply
??ldply
?ldplyr
?dplyr
library(aomisc)
data(metamitron)
library(plyr)
?ldply
library(aomisc)
library(aomisc)
